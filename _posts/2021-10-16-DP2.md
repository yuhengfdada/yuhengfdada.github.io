---
title: "Dynamic Programming - 2 - 01Knapsack"
categories:
  - Blog
tags:
  - LeetCode
  - Dynamic Programming
---

背包问题。

# 01背包

之所以叫01背包，是因为每个物品只有拿或不拿两个状态。

![01knapsack](/assets/dp/01knapsack.png)

做一个二维数组dp，i表示拿不拿第i个物品，j表示背包容量。每个节点两种情况：

* 拿物品i，最大价值=dp[i-1]\[j-weight(i)]+value(i)
* 不拿物品i，最大价值=dp[i-1]\[j]

遍历顺序是左上角到右下角（上图中手动画一根对角线）。

是不是很简单呢。

## 01背包的一维写法

![01k2](/assets/dp/01k2.png)

注意：之所以可以坍缩成一维，是因为二维中每一行`i`都只与前一行`i-1`相关。

**牢记：dp[j] = 容量为j的背包在前i个物品中挑选，能够装载的最大值。这里的i不在dp数组里，而是在外循环中。**

# [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

转换问题（很关键）：搜索和等于sum/2的子集，搜索到了就返回true。

可以用回溯+memoization，或者0-1背包bottom-up来做。每个元素的weight和value都是元素本身。

# [1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)

这题完全想不出怎么转换问题，无奈了。

转换问题：将石头尽量分成重量相同的两堆，这样对撞起来会剩得最少。

0-1背包，容量=sum(stones)//2。每个元素的weight和value都是元素本身。

# 小结

这两道题其实第一眼很难做，第二眼也很难把它转换成标准的0-1背包来做。但是通过模板+**每个元素的weight和value都是元素本身**这样的settings，很轻松就可以写出来了。**上面两题的套路完全一样**，只不过最后对dp输出的处理，416是判断dp[-1]\[-1]是否等于target，1049是return sum-2*dp[-1]\[-1]。

另外还需要理解一维数组这个优化。优化之后代码量会显著减少。

附最佳代码：

416

```python
def canPartition(self, nums: List[int]) -> bool:
    if sum(nums) % 2:
        return False
    target = sum(nums) // 2

    dp = [0] * (target+1)
    for i in range(len(nums)):
        for j in range(target, nums[i]-1, -1):
            dp[j] = max(dp[j], dp[j-nums[i]]+nums[i])
    return target == dp[-1]
```

1049

```python
def lastStoneWeightII(self, stones: List[int]) -> int:
    target = sum(stones) // 2
    dp = [0] * (target+1)
    for i in range(len(stones)):
        for j in range(target, stones[i]-1, -1):
            dp[j] = max(dp[j], dp[j-stones[i]]+stones[i])
    return sum(stones) - 2*dp[-1]
```



